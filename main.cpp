#define _USE_MATH_DEFINES
#include <iostream>
//#include "Swap.h"
#include <ctime>
#include <vector>
#include <chrono> //for accurate multithreading time using std::chrono
//#include "EulerSimulation.h"
//#include "Matrix.h"
//#include "Double.h"
#include "Date.h"
#include "BlackScholes.h"
#include "Vasicek.h"
#include "MarketData.h"
#include "Newton.h"


/*struct SpotValue {
  Date date;
  double value;
}*/
/*struct ForwardValue{
  Date beginDate;
  Date endDate;
  Double value;
};
Matrix alpha(double t, Matrix &x){
  return .1*x;
}
Matrix sigma(double t, Matrix &x){

  return .3*x;
}
double callback(Matrix val, double valth){
  return val.l1norm();
}*/

//double meanSquare(std::vector<SpotValue> &volatility){

//}

int main(){
  double a=.4; //speed
  double b=.05; //long run average
  double sig=.05; //volatility of the process
  double t=1;
  double r0=.03;
  double delta=.25;

  /*Newton Test */
  /*This demonstrates the workflow for estimating and using a one dimensional Vasicek model for VaR purposes in a fixed income portfolio.  The risk neutral parameter is assumed to be "mu".  Hence the "speed" and "volatility" are constant between the risk neutral and real world Vasicek processes. */

  //First, need to estimate volatility (by Girsonav's theorem, this doesn't change under measure change for a diffusion)
  Newton nt;
  int m=10;//number of volatility dates...calibrate to volatility smile

  //Create "fake" volatility surface.  Note that this is created from the assumption that the actual generating process is indeed a Vasicek process.  In a real world implementation, this data would be given to us by the market and we wouldn't "create" it
  std::vector<SpotValue> val;
  Date volDate;
  volDate.setScale("year");
  double volDateD=0;
  for(int i=0;i<m;i++){
    volDateD=(i+1)*.25;
    val.push_back(SpotValue(volDate+volDateD, Vasicek_Volatility(a, sig,volDateD+delta, volDateD)));
  }


  //create optimization functions
  std::vector<std::function<double(std::vector<double>&, std::vector<double>&)> > meanSquare;
  int n=val.size();
  std::vector<double> dataToMinimizeOver(n); //the volatility from above
  std::vector<std::vector<double> > additionalParameters(n, std::vector<double>(2)); //a and sigma
  for(int i=0; i<n; i++){ //populate our functions to minimize over.
    Date dt=val[i].date;
    dataToMinimizeOver[i]=val[i].value;
    dt.setScale("year");
    Date currDate;
    double dtdiff=dt-currDate;
    additionalParameters[i][0]=dtdiff+delta;
    additionalParameters[i][1]=dtdiff;
    meanSquare.push_back([](std::vector<double> &guess, std::vector<double> &additionalParameters){
      return Vasicek_Volatility(guess[0], guess[1], additionalParameters[0], additionalParameters[1]);
    });
  }
  std::vector<double> guess(2);
  guess[0]=.3;
  guess[1]=.1;
  nt.optimize(meanSquare, additionalParameters, dataToMinimizeOver, guess); //optimize.  "Guess" is passed by reference and is adjusted.
  std::cout<<guess[0]<<", "<<guess[1]<<std::endl; //note that this gives us a=.4 and sigma=.05; exactly what we had created
  /*End newton test*/

  //Now we calibrate the "risk neutral" parameter "theta" (from dr=a(theta(t)-r)dt+sigma dW).  Note that this parameter is time dependent but assumed piecwise constant between yield curve dates.  This parameter is calibrated from the yield curve

  //create "fake" yield curve.  Note that this is created from the assumption that the yield curve is generated by bonds that are "derivatives" of a Vasicek process.
  std::vector<SpotValue> yield;
  Date dt;
  dt.setScale("year");
  double delt=0;
  for(int i=0; i<20; i++){
    delt=(i+1)*.25;
    std::cout<<dt+delt<<": ";
    std::cout<<-log(Vasicek_Price(r0, a, b, sig, delt))/delt<<std::endl;
    yield.push_back(SpotValue(dt+delt, -log(Vasicek_Price(r0, a, b, sig, delt))/delt));
  }

  //Now we actually fit the data.  Note that the constructor automatically creates the "Theta" that fits the data.
  Vasicek vs(yield, a, sig, r0); //this construtor currently prints the estimate of "theta".  In this example, these estimates are constant (since theta(t)=mu for all t)
  std::cout<<vs.Bond_Price(t)<<std::endl; //This should be the same as the below
  std::cout<<Vasicek_Price(r0, a, b, sig, t)<<std::endl;  //This should be the same as above.
  std::cout<<Vasicek_Caplet(r0, a, b, sig, .04, delta, t)<<std::endl; //option on simple interest rate




  //BlackScholes bs(s0, bnd.getPrice(r0), k, t);
  //std::cout<<bs.getPut(bnd.getVasicekVolatility(delta))<<std::endl;
  //BlackScholes tst(40, exp(-.03), 40, 1);
  //std::cout<<tst.getCall(.3)<<std::endl;
  /*std::vector< std::vector<double> > sigs(3, std::vector<double>(3));
  sigs[0][0]=.3;
  sigs[1][0]=.2;
  sigs[2][0]=.4;
  sigs[0][1]=0;
  sigs[1][1]=.15;
  sigs[2][1]=.3;
  sigs[0][2]=0;
  sigs[1][2]=0;
  sigs[2][2]=.3;
  Matrix sig(sigs);
  int n=5;
  std::vector<ForwardValue> forwardLIBOR(n);
  //for(int i=0; i<n;i++){
  forwardLIBOR[0]={"1/1/2015", "3/31/2015", .03};
  forwardLIBOR[1]={"2/1/2015", "4/30/2015", .03};
  forwardLIBOR[2]={"3/1/2015", "5/31/2015", .03};
  forwardLIBOR[3]={"4/1/2015", "6/30/2015", .03};*/
  //}
  /*int ncol=5;
  int nrow=4;
  std::vector<std::vector<double> > matP(nrow, std::vector<double>(ncol, 0));
  std::vector<double> vP(ncol, 0);
  for(int i=0; i<ncol; i++){
    for(int j=0; j<nrow; j++){
      matP[j][i]=(i+1)*(j+1)*5;
    }
    vP[i]=i+3;
  }
  Matrix mat(matP);
  //std::cout<<vP[2]<<std::endl;
  Matrix mt=mat*vP;
  //std::cout<<mt.getNumRow()<<std::endl;
  for(int i=0; i<nrow; i++){
    std::cout<<mt[i][0]<<std::endl;
  }*/

/*  Double x=5;
  std::cout<<x*5<<std::endl;
  Date expiration("1/1/2016");
  Date current;
  std::cout<<expiration-current<<std::endl;
  EulerSimulation<Matrix> ms(100, 100000, 1);

  auto start = std::chrono::system_clock::now();
  std::vector<std::vector<double> > init(3, std::vector<double>(1));
  init[0][0]=.8;
  init[1][0]=1.1;
  init[2][0]=1.3;
  ms.simulate(Matrix(init), alpha, [&](double t, Matrix x){return sig;});
  auto end=std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now()-start);
	std::cout<<"Time it took: "<<end.count()/1000.0<<std::endl;
  std::cout<<ms.getResult()<<std::endl;
  std::cout<<ms.getMCVol()<<std::endl;*/




  /*int numL=20;
	std::vector<double> libor(numL);
  for(int i=0; i<numL; i++){
    libor[i]=.01*i;
  }
  Swap swp(libor, .5);
  double rate=swp.getRate(5);
  std::cout<<rate<<std::endl;
  std::cout<<swp.getPrice(5, rate)<<std::endl; //this is zero (as it should be)
  std::cout<<swp.getBondYield(5)<<std::endl; //should be nearish the swap rate*/
}
